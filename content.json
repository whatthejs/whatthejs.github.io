{"meta":{"title":"WhatTheJS","subtitle":"Demystifying the ever changing world of Javascript","description":null,"author":"Colyn Brown","url":"http://whatthejs.github.io"},"pages":[{"title":"About","date":"2016-04-30T20:38:08.000Z","updated":"2016-04-30T23:16:43.000Z","comments":true,"path":"about/index.html","permalink":"http://whatthejs.github.io/about/index.html","excerpt":"","keywords":null,"text":"Phoenix, AZ I’ve been doing web development for about 15 years. I’m currently Senior UI Architect for Investability.com, an online search and acquisition platform transforming the way in which investors from around the globe acquire Real Estate in the U.S. I’m currently building up my consultancy and training business (WhatTheCode?), providing expertise to many startups and where I am now teaching junior and intermediate developers. Courses I’m currently teaching: Javascript Fundamentals Event delegation Making code more modular Understanding closures and javascript internals Demystifying jQuery ReactJS Basics Preparing your local environment and tooling Comparing/contrasting ReactJS with other frameworks; Understanding trade-offs Understanding what app state is and how to represent it in a ReactJS app Pure functions as components Data persistence My courses are conducted over Skype but I’m open to whatever suits your needs. Contact me for rates.","raw":null,"content":null}],"posts":[{"title":"How to Understand Application State","slug":"How-to-Understand-Application-State","date":"2016-04-30T23:21:55.000Z","updated":"2016-05-01T00:33:41.000Z","comments":true,"path":"2016/04/30/How-to-Understand-Application-State/","link":"","permalink":"http://whatthejs.github.io/2016/04/30/How-to-Understand-Application-State/","excerpt":"","keywords":null,"text":"State is a concept most people have a hard time explaining. Like all things it all depends on the context. A frequently used definition, when talking about it as part of a React application, is that state is “data that changes over time”. This definition doesn’t make it all that clear what state is. I think “state” is actually more abstract than that. I would go further and say that it’s not data that changes over time but the user interface - the visible representation of your application - that changes over time. The data is just one method for describing those visible changes. Let’s look at it another way. Imagine you’re a UX designer and it was your responsibility to design a new application for your company. Before any code is written, the first few stages of design involve you creating wireframes, then finally on to high fidelity mockups. It’s your responsibility to anticipate how the user will interact with the application and to make sure that all those interactions are spec’d out into mockups before any code or data structures ever cross anyone’s mind. In effect, what you are already doing is describing the state of the application with every step the user takes getting through it, using individual screenshots. As we will see, for the developer who will be developing the application, especially in React, this will prove to be very insightful. Before the developer writes a single line of code; before they write any data structures at all, the first thing she should be doing is analyzing each of your screens. She will look at them then write down the differences between them. Those differences are what she will use to help her decide how to best represent the state as data structures. In a React application those differences, as defined in the new data structures, are what they mean by “data changing over time”. Let’s take a more concrete example. Imagine you’re the developer this time and your designer gave you two screenshots for an application. One is just a website homepage with some marketing copy. The other is the same page but with a login modal. Describing the differences is quite easy: On the first screen the modal is not open On the second screen the modal is open (caused by a button click) There are no other changes to the UI; the marketing copy didn’t change; navigation links didn’t change. The fact that the modal is either open or not open, can be described in data very easily: 123456789// default statevar state = &#123; modalIsOpen: false;&#125;;...// for the sake of simplicity, a login button is clicked and runs this function:function handleClick() &#123; state.modalIsOpen = true;&#125; (Note: the above is pseudo-code in case it’s not obvious) This is the beauty of React. As a React developer, your primary responsibility is to describe your application in data only. Your designer worries about what your application will look like during different state transitions. In the above example, your only job is to set modalIsOpen to true or false. Then React takes care of all the messy work of getting the DOM updated with any new HTML your application needs to represent the new state.","raw":null,"content":null,"categories":[{"name":"React","slug":"React","permalink":"http://whatthejs.github.io/categories/React/"}],"tags":[]},{"title":"Easy Frontend Tooling with Laravel Elixir - Without Laravel!","slug":"laravel-elixir","date":"2016-04-30T13:30:04.000Z","updated":"2016-04-30T20:05:49.000Z","comments":true,"path":"2016/04/30/laravel-elixir/","link":"","permalink":"http://whatthejs.github.io/2016/04/30/laravel-elixir/","excerpt":"","keywords":null,"text":"Frontend tooling has gotten really complicated and it’s no longer an aspect of your project you can ignore. You really don’t need me to convince you right? Every project demands a level of my attention on things that shouldn’t matter. I just want to build apps! More importantly, so does your team, and they want to do it quickly. So, what is Laravel Elixir and how will it get me to building apps faster? First, Laravel itself, as some of you might know, is a PHP MVC framework. It has a lot of great features but Laravel also comes with Elixir, which the documentation explains: Laravel Elixir provides a clean, fluent API for defining basic Gulp tasks for your Laravel application. Elixir supports several common CSS and JavaScript pre-processors, and even testing tools. Using method chaining, Elixir allows you to fluently define your asset pipeline. For example, if you need to compile sass you don’t have to install any additional plugins - Elixir ships with the most common. This is your gulpfile.js file: 12345var elixir = require('laravel-elixir');elixir(function(mix) &#123; mix.sass('app.sass');&#125;); Just this little bit of code comes packed with features you normally would have to prepare separately. When you run gulp in the terminal, Elixir will automatically build your css file with sourcemaps, when not running in production. It knows where your source files are and it knows where to save them to after compile. The reason it can do so much is because it assumes you’ve installed a full Laravel application. Because you’ve installed Laravel, it knows that you save your source files in specific folders; it knows where your public folder is so it can save the output without you having to specify it. It passes these configuration options to Elixir. However, these configuration options can be changed. This is why it’s so simple to use Elixir in your own non-Laravel projects. Either use Laravel’s folder conventions or change the configuration options, and you’ll be using Elixir in your own projects! So let’s get started!Install Laravel Elixir1$ npm install laravel-elixir Set up the folders for saving your source files to:This creates a resources/assets/sass and a resources/assets/js folder at the root of your project.1$ mkdir -p resources/assets/&#123;sass,js&#125; Make sure you have a public folder:1$ mkdir public Prepare your gulp file:Besides compiling Sass, Elixir ships with many other tasks including one for compiling Javascript with Browserify. So, let’s create a file for compiling both Sass and Javascript: 123456var elixir = require('laravel-elixir');elixir(function(mix) &#123; mix.sass('app.sass'); mix.browserify('main.js');&#125;); Look how wonderfully clean that is! What if you don’t like the default choice for file locations? Well with Elixir, configuring paths is straight-forward. Let’s say I wanted to have all my source files (sass, jsx, etc) in a different folder, one called src (instead of resources/assets)? I also wanted those files to be compiled to a folder called build (instead of public)? Easy! 123456789var elixir = require('laravel-elixir');elixir.config.assetsPath = 'src';elixir.config.publicPath = 'build';elixir(function(mix) &#123; mix.sass('app.sass'); mix.browserify('main.js');&#125;); And there you have it. Elixir ships with many other tasks like browsersync, coffeescript, file versioning/cache busting, copying files and folders, and more. Note, that when you need to ship your assets to production, just run gulp with the production flag - which minifies/uglifies your assets: gulp --production. Sweet! Head over to Elixir’s documentation to get a ton more detail.","raw":null,"content":null,"categories":[{"name":"Tooling","slug":"Tooling","permalink":"http://whatthejs.github.io/categories/Tooling/"}],"tags":[]}]}